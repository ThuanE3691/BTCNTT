// Đề: https://colab.research.google.com/drive/17T717GftCNjdgkn0nIDU47djAPHq8_jj?usp=sharing
// Code:
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <list>

using namespace std;

class Graph {
private:
	vector < vector <int> > G;
	map < string, int > list;
	vector <string> key;
	std::list <string> Open;
	vector < bool > Close;
	map < string, string> parent;
public:
	void initGraph() {
		int v, e;
		string u, j;
		cin >> v >> e;
		G = vector < vector <int> >(v, vector <int>(v, 0));
		for (int i = 0; i < v; i++) {
			cin >> u;
			list[u] = i;
			key.push_back(u);
		}
		for (int i = 0; i < v; i++)
			for (int j = 0; j < v; j++) {
				cin >> G[i][j];
			}
		while (e--) {
			cin >> u >> j;
			Close.assign(v, false);
			parent.clear();
			if (dfs(u, j,v)) {
				int count = 0;
				int length = findPath(u, j);
				for (int i = 0; i < v; i++)
					if (Close[i] == true) count++;
				cout << count << " " << length << endl;
			}
			else {
				int count = 0;
				cout << "-unreachable-" << endl;
				for (int i = 0; i < v; i++)
					if (Close[i] == true) count++;
				cout << count << " " << 0 << endl;
			}
			Open.clear();
		}
	}
	bool dfs(string s, string t,int V) {
		Open.push_back(s);
		Close[list[s]] = true;
		while (!Open.empty()) {
			string u = Open.front();
			Open.pop_front();
			for (int v = 0; v < V; v++) {
				if (G[list[u]][v] > 0 && Close[v] == false) {
					Close[v] = true;
					Open.push_back(key[v]);
					parent[key[v]] = u;
					if (key[v] == t) return true;
				}
			}
		}
		return false;
	}
	int findPath(string s, string t) {
		int length = 0;
		std::list < string > Path;
		while (t != s) {
			Path.push_back(t);
			string u = parent[t];
			length += G[list[u]][list[t]];
			t = parent[t];
		}
		Path.push_back(s);
		while (!Path.empty()) {
			cout << Path.back() << " ";
			Path.pop_back();
		}
		cout << endl;
		return length;

	}

};

int main() {
	Graph G;
	G.initGraph();

}
